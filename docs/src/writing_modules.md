# Writing Modules

This chapter is a tutorial which covers the basics of writing modules for
Icejar. For real-world examples of modules which add real functionality rather
than being contrived demonstrations of Icejar's features, see the
[example modules](example_modules.md).

## Setup

You can use a proper build system to write modules, but in this tutorial we
will just be using the Java compiler directly.

Create a directory called `demo_module` with the following contents:

* A new file called `Module.java`: this will be the source for the module
* `MumbleIceModuleAPI.jar` (see [Building](building.md))


## Step 1: Essentials

Add the following contents to `Module.java`:

```java
import MumbleServer.*;
import com.zeroc.Ice.ObjectAdapter;
import com.zeroc.Ice.Current;

import java.util.Map;


public class Module implements icejar.Module {

    @Override
    public void setup(
            Map<String, Object> cfg, MetaPrx meta,
            ObjectAdapter adapter, ServerPrx server)
            throws Exception
    {
        System.out.println("I'm alive!");
    }
}
```

You can now run the following from the `demo_module` directory to compile
the module:

```shell
$ javac -classpath MumbleIceModuleAPI.jar Module.java
```

This is the bare minimum for an Icejar module:

* It implements the `Module` interface from the `icejar` package.
* It contains an implementation of the `setup` method.
* `import MumbleServer.*` provides the auto-generated types used to interface
  with a Mumble server over Ice (such as `MetaPrx` and `ServerPrx`).
* [`ObjectAdapter`](https://doc.zeroc.com/api/ice/3.7/java/com/zeroc/Ice/ObjectAdapter.html)
  allows new objects to be registered with Ice. This is needed to add callbacks
  to the Mumble server.
* [`Current`](https://doc.zeroc.com/api/ice/3.7/java/com/zeroc/Ice/Current.html)
  provides access to the state of the current Ice connection.

Modules must provide a constructor with no arguments, i.e. `new Module()` must
be a valid way to create an instance. In this example we don't specify any
constructor so the default constructor is automatically provided, but this is
worth keeping in mind if you write a module which defines its constructor.

The arguments to the `setup` method are the following:
* `cfg` - A mapping from configuration option names to their values. The
  configuration for each module is read from the server and passed in to the
  relevant module by Icejar.
* [`meta`](../ice-generated/MumbleServer/MetaPrx.html) - Provides access to global Mumble server functionality, such as
  getting the version number of the Mumble server, getting its current uptime,
  or reading values from the Mumble server INI configuration file. It also
  facilitates control of the Mumble server's
  [virtual servers feature](https://wiki.mumble.info/wiki/FAQ/English#Can_I_run_multiple_servers_on_one_host.3F).
* [`adapter`](https://doc.zeroc.com/api/ice/3.7/java/com/zeroc/Ice/ObjectAdapter.html) - This is provided to allow creating new objects which communicate
  with the Mumble server over Ice. It is mainly needed to create callbacks.
* [`server`](../ice-generated/MumbleServer/ServerPrx.html) - Provides access to the specific virtual server for which the
  module was instanced. This can be used to send messages to the server,
  access/modify user data, modify channels, etc.

The `setup` method is called _each_ time a connection to a Mumble server is
established for the given module and modules should _not_ assume that `setup`
is only called for newly constructed instances.

More specifically: if a module is instatiated and connects to a Mumble server,
`setup` will be called. Importantly, if the Mumble server stops or the
connection is othewise interrupted and then the Mumble server becomes available
again, `setup` will called with the new connection details for the _same_
instance of the module.


## Step 2: Adding a Callback

Callbacks are objects which provide methods to be called in response to events
which occur on the Mumble server. In this step, we will add a callback which
responds to text messages being sent on the Mumble server.

add the following class to `Module.java` (note that this class is _not_ public):

```java
class Callback implements icejar.DefaultServerCallback {

    @Override
    public void userTextMessageThrowsException(
            User state, TextMessage message, Current current)
            throws Exception
    {
        System.out.println(message.text);
    }
}
```

This callback will print the contents of each text message which gets sent to
the Mumble server.

The interface which must be implemented by server callbacks is generated by Ice
and can be unwieldly to use, since it requires a handler method for each type
of event and does not allow said handler methods to throw exceptions. For this
reason, Icejar provides a sub-interface called
[`DefaultServerCallback`](../module-api/icejar/DefaultServerCallback.html)
which provides a default handler for each event type that does nothing and
allows handler methods to throw exceptions. This allows you to only implement
the methods you need, as demonstrated above.

Just defining the callback isn't enough: it needs to be added to the server. To
do this, add the following import statement to the top of `Module.java`:

```java
import static icejar.IceHelper.*;
```

The [`IceHelper`](../module-api/icejar/IceHelper.html) utility class provides
the `addServerCallback` method. To use it, add the following to the body of the
`setup` method on the `Module` class:

```java
addServerCallback(server, adapter, new Callback());
```

There is now enough functionality that this module will do something if it is
added to a Mumble server. You can package it up into a JAR file using the
following commands:

First, compile the module with:

```shell
$ javac -classpath MumbleIceModuleAPI.jar Module.java
```

Then, create the JAR file containing the module with:

```shell
$ jar cf demo_module.jar *.class
```

Following the instructions in the [usage](usage.md) chapter, you can see the
module in action!


## Step 3: Message Passing

Icejar has a message passing feature to support communication between modules.
To demonstrate this feature in this tutorial, message passing will be used to
send a message from `demo_module` to itself. This is redundant, but will show
how to properly use the message passing API.

First, import the [`MessagePassing`](../module-api/icejar/MessagePassing.html)
utility class:

```java
import static icejar.MessagePassing.*;
```

We're going to make it so that instead of just printing messages to the
standard output, the module sends a text message back with the same contents
like an echo.

Add an instance variable to `Module` so that it can keep track of the
`ServerPrx` object which we'll need to send messages to the server.

Add the following to the `Module` class:

```java
private ServerPrx server;
```

and add the following to the body of its `setup` method:

```java
this.server = server;
```

Now, we can access `server` in any of `Module`'s instance methods (provided
they get called after the call to `setup`).

Add the following method to `Module`:

```java
public void echoTextMessage(TextMessage message) {
    try {
        sendMessageSameDestination(server, message, message.text);
    } catch (Exception e) {
        System.err.println(e);
    }
}
```

The [`TextMessage`](../ice-generated/MumbleServer/TextMessage.html) object
stores not only the contents of the message, but its destination as well. Using
the
[`sendMessageSameDestination`](../module-api/icejar/IceHelper.html#sendMessageSameDestination(MumbleServer.ServerPrx,MumbleServer.TextMessage,java.lang.String))
helper method, we can send the `message.text` String to the same destination as
`message`.

This call might result in an error (if the connection to the Mumble server
died, etc.) so we'll wrap it in a `try ... catch` block.

Right now, the method to respond to messages is in the `Module` class, but
messages are received by the `Callback` class. We will use message passing to
send instances of `TextMessage` from `Callback` to `Module`.

To get access to Icejar's message passing features, we implement the
[`setupMessagePassing`](../module-api/icejar/Module.html#setupMessagePassing(icejar.MessagePassing.Coordinator))
method for `Module`.

Add the following method to the `Module` class:

```java
@Override
public void setupMessagePassing(Coordinator c) {
    Receiver<TextMessage> receiver = c.getReceiver(TextMessage.class);
    receiver.setHandler(this::echoTextMessage);
    sender = c.getSender("demo_module");
}
```

Additionally, add `sender` as an instance variable of `Module` like so:

```java
private Sender<TextMessage> sender;
```

The [`Coordinator`](../module-api/icejar/MessagePassing.Coordinator.html)
object allows the creation of
[`Senders`](../module-api/icejar/MessagePassing.Sender.html)
and
[`Receivers`](../module-api/icejar/MessagePassing.Receiver.html)
for the current module.

`Receivers` implicity receive messages for the current module and are created
by providing the expected type for values sent to the `Receiver`. In this example,
the receiver expects `TextMessage` objects.

Since the message passing API is intended for sending messages _between_
modules instead of within the same module like in this example, `Senders` are
created with the name of the module to which its messages will be sent. In
this example the name of the current module, `"demo_module"`, is used.

The behaviour of a `Receiver` upon receiving a message is defined using its
`setHandler` method. This method sets the method to call when a message is
received. The given method must have no return value (`void`) and accept a
single parameter: a value of the type expected by the `Receiver`. In this
example, we can use `this::echoTextMessage` as the handler method since it
meets the criteria.

Right now `Module` can receive `TextMessage` objects and echo their contents
back to the Mumble server, but `Callback` still doesn't have access to a
`Sender`.

To fix this, add the following constructor to `Callback`:

```java
public Callback(Sender<TextMessage> sender) {
    this.sender = sender;
}
```

Additionally, add the `sender` instance variable:

```java
private Sender<TextMessage> sender;
```

Now, the following can be added to the `userTextMessageThrowsException` method
to pass the incoming `TextMessages` to `Module`:

```java
sender.send(message);
```

The print statement can now be removed, since we will be able to see that the
module is working in the Mumble chat log.

Finally, update `Module`'s `setup` method to instantiate `Callback` using its
new constructor:

```java
addServerCallback(server, adapter, new Callback(sender));
```

`setupMessagePassing` is guaranteed to be called _before_ `setup`, so we can
use the `sender` instance variable without worrying about it being `null`.

If you re-compile and package the module and run it with Icejar, you will see
that every time you send a message on the Mumble server, the server repeats the
same message.

If you're wondering why this doesn't result in an infinite loop, it's because
the Mumble server doesn't create `userTextMessage` events for messages sent
using Ice.


## Step 4: Custom Configuration

Often, you'll want to make some values in your module modifiable by its users
without having to edit the source code and re-compile.

First, import the [`ConfigHelper`](../module-api/icejar/ConfigHelper.html)
utility class:

```java
import static icejar.ConfigHelper.*;
```

We're going to make it so that instead of just repeating messages, the module
adds some text before and after each message.

To use the `ConfigHelper`, we must first define the data to parse. We will do
this with a `Record` class. Add the following `Record` class as a nested class
within the `Module` class:

```java
public static record Config(String beforeMessage, String afterMessage) {}
```

We can now add a call to the
[`parseConfig`](../module-api/icejar/ConfigHelper.html#parseConfig(java.util.Map,java.lang.Class))
helper method to the body of the `setup` method in `Module`:

```java
config = parseConfig(cfg, Config.class);
```

Additionally, we'll need to add a `config` instance variable to `Module`:

```java
private Config config;
```

Now, we can modify the `echoTextMessage` method to use `config` like so:

```java
String response = 
    config.beforeMessage()
    + ' ' + message.text + ' '
    + config.afterMessage();

sendMessageSameDestination(server, message, response);
```

If `beforeMessage` and `afterMessage` are undefined, response will just be
`message.text` with `null` before and after. This could be handled, but we
won't for brevity's sake.

To configure the values of `beforeMessage` and `afterMessage`, the following
would be added to the server configuration file
(see [usage](usage.md#using-modules)):

```toml
[demo_module]
before_message = "something"
after_message = "something else!"
```

With these settings, the module would respond to the message containing "foo"
with "something foo something else!"

Since TOML values are written in `pothole_case` while Java members use
`camelCase`, the `parseConfig` method automatically converts from the former
to the latter, i.e. `before_message` sets the `beforeMessage` member of
`Config` while `after_message` sets the `afterMessage` member.


## Step 5: Logging

So far, we've used print statements everywhere in our module. This would
quickly get out of hand if you were running multiple modules which all print
their own messages.

To solve this, Icejar provides a `Logger` to which messages can be written
instead of printing them directly from the module.

First, import the Java `Logger` class:

```
import java.util.logging.Logger;
```

Next, implement the
[`setLogger`](../module-api/icejar/Module.html#setLogger(java.util.logging.Logger))
method for `Module`:

```java
@Override
public void setLogger(Logger logger) {
    this.logger = logger;
}
```

Additionally, add the `logger` instance variable:

```java
private Logger logger;
```

Now, instead of using a print statement in `Module`'s `setup` method, we can
use the following:

```java
logger.info("I'm alive!");
```

This will automatically timestamp the message and show the server _and_ module
from which the message originates.


## Complete Source Code

Here is the complete source code for `Module.java` after completing all the
steps:

```java
import MumbleServer.*;
import com.zeroc.Ice.ObjectAdapter;
import com.zeroc.Ice.Current;

import static icejar.IceHelper.*;
import static icejar.MessagePassing.*;
import static icejar.ConfigHelper.*;

import java.util.Map;
import java.util.logging.Logger;


public class Module implements icejar.Module {

    public static record Config(String beforeMessage, String afterMessage) {}

    private ServerPrx server;
    private Sender<TextMessage> sender;
    private Config config;
    private Logger logger;

    @Override
    public void setupMessagePassing(Coordinator c) {
        Receiver<TextMessage> receiver = c.getReceiver(TextMessage.class);
        sender = c.getSender("demo_module");

        receiver.setHandler(this::echoTextMessage);
    }

    public void echoTextMessage(TextMessage message) {
        try {
            String response = 
                config.beforeMessage()
                + ' ' + message.text + ' '
                + config.afterMessage();

            sendMessageSameDestination(server, message, response);
        } catch (Exception e) {
            System.err.println(e);
        }
    }

    @Override
    public void setLogger(Logger logger) {
        this.logger = logger;
    }

    @Override
    public void setup(
            Map<String, Object> cfg, MetaPrx meta,
            ObjectAdapter adapter, ServerPrx server)
            throws Exception
    {
        logger.info("I'm alive!");

        this.server = server;
        config = parseConfig(cfg, Config.class);

        addServerCallback(server, adapter, new Callback(sender));
    }
}


class Callback implements icejar.DefaultServerCallback {

    private Sender<TextMessage> sender;

    public Callback(Sender<TextMessage> sender) {
        this.sender = sender;
    }

    @Override
    public void userTextMessageThrowsException(
            User state, TextMessage message, Current current)
            throws Exception
    {
        sender.send(message);
    }
}
```
