package icejar;

import java.util.Optional;
import java.util.Map;

import Murmur.*;

/**
 * Modules must be <code>.jar</code> files containing a class named "Module"
 * which extends this abstract class.
 * <p>
 * Implementations of Module must provide the default contstructor, i.e.
 * <code>new Module()</code> must be a valid way of creating an instance.
 * <p>
 * Be aware that instances of Module will be accessed from different threads:
 * setup and cleanup will be initiated by the main class, but any functionality
 * you register as a callback using the Ice interfaces will be spawned on a
 * thread pool managed by Ice. Make sure that a call to <code>setup()</code> or
 * <code>cleanup()</code> is thread-safe given that other logic from your
 * implementation may be executing in a different thread.
 */
public abstract class Module {
    /**
     * Interface generated by ZeroC Ice providing access to a single virtual
     * server. This member is optional since Ice clients may not be configured
     * to connect to a specific virtual server.
     * <p>
     * The value of this member may be changed and its previous value made
     * invalid, so its value should never be stored in another variable and it
     * should always be accessed directly to ensure the correct value is used.
     */
    protected volatile Optional<ServerPrx> server;

    /**
     * Interface generated by ZeroC Ice providing access to general
     * functionality.
     * <p>
     * The value of this member may be changed and its previous value made
     * invalid, so its value should never be stored in another variable and it
     * should always be accessed directly to ensure the correct value is used.
     */
    protected volatile MetaPrx meta;

    /**
     * Makes a call to <code>setup()</code> which will not occur at the same
     * time as any other call to <code>synchronizedSetup()</code> or
     * <code>synchronizedCleanup()</code>.
     */
    public final void synchronizedSetup(Map<String, Object> config) throws Exception {
        setupOrCleanup(true, config);
    }

    /**
     * Makes a call to <code>cleanup()</code> which will not occur at the same
     * time as any other call to <code>synchronizedCleanup()</code> or
     * <code>synchronizedSetup()</code>.
     */
    public final void synchronizedCleanup() throws Exception {
        setupOrCleanup(false, null);
    }

    private synchronized void setupOrCleanup(
            boolean callSetup, Map<String, Object> config) throws Exception
    {
        if (callSetup) {
            setup(config);
        } else {
            cleanup();
        }
    }

    /**
     * Set up a Module when a connection is established.
     * <p>
     * Be aware that the connection to the server will be closed and re-opened
     * when modules for a Client are reloaded. Even if a specific Module was not
     * reloaded, its connection will still be interrupted and its
     * <code>setup()</code> method will be called. <code>setup()</code> should
     * be implemented with the knowledge that it may be called several times.
     *
     * @param config The parsed configuration for the Client to which this
     * Module instance belongs.
     */
    public abstract void setup(Map<String, Object> config) throws Exception;

    /**
     * Clean up a Module when it is unloaded.
     * <p>
     * This method should be overridden if your Module requires any extra
     * cleanup. Callbacks registered with Ice are removed automatically and do
     * not require any implementation of this method.
     */
    public void cleanup() throws Exception {}
}
